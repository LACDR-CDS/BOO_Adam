setequal(rownames(countData), manifest$probe_name_old)
#
NA_gene_symbol<- sum(is.na(manifest$gene_symbol))
NA_gene_symbol
# Counting the amount of genes that still have the same symbol as before the update
manifest %>%
count(gene_symbol == gene_symbol_old)
# Adding an empty column called flag_realignment
manifest %>%
add_column(flag_realignment = NA)
# flag_realignment column now describes whether a probe should be removed, renamed or kept unchanged.
manifest <- manifest %>%
mutate(flag_realignment =
# when the new gene symbol is equal to the old one, write "unchanged"
case_when(gene_symbol_old == gene_symbol ~ "unchanged",
# when the new gene symbol is not equal to the old one, write "renamed"
gene_symbol_old != gene_symbol ~ "renamed",
# when the new gene symbol is NA, write "removed"
is.na(gene_symbol) ~ "removed"))
# checking if the flag realignment went well. If the realignment went well, this should say: removed: 603, renamed: 608, unchanged: 21322, NA: 0
table(manifest$flag_realignment, useNA = "always")
# subsetted countData to only show the probes which do not have the tag "removed" in the flag_realignment column of manifest_new
countData <- subset(countData, row.names(countData) %in% manifest$probe_name_old & manifest$flag_realignment != "removed")
# The mutate verb adds a probe_name column. The new probe names are gene_symbol and probe_ID, separated by an underscore.
manifest <- manifest %>%
mutate(probe_name = paste(gene_symbol, probe_ID, sep = "_"))
countData <- countData %>%
# turning the row names (probes) back into a column
rownames_to_column(var = "probe_name_old") %>%
# merging the countData with manifest
left_join(y = manifest, by= "probe_name_old") %>%
# selecting only the probe_name and sample_ID columns, these are the two columns of the manifest that will be used in the countData
select(probe_name, all_of(metaData$sample_ID)) %>%
# changing the column probe_name to rownames of the countData: probe_name_old has now been swapped for the new probe_name.
column_to_rownames(var="probe_name")
# checking dimensions of the manifest (should be 22533/13 for manifest and 21930 (=22533-603) for countData, 66/29 for metaData)
dim(manifest)
dim(countData)
dim(metaData)
# calculating the counts per million and putting them in a dataframe
cpmData <- data.frame(
# the apply function is used to apply the calculation to the columns ("2") of the countData
apply(countData, 2,
# cpm = (counts / sum of all counts in the column) * 1 million
function(x){x/sum(x)*1000000}))
# First removed the unassigned probes from the manifest, so no error would occur because of the removed probes in the countdata.
manifest <- subset(manifest, row.names(countData) %in% manifest$probe_name & manifest$flag_realignment != "removed")
# The rm function clears the environment from all objects.
rm(list=ls())
# Loading the needed packages (loaded more than specified, because more packages were needed)
library(readxl)
library(tidyverse)
library(dplyr)
library(sessioninfo)
library(ggplot2)
# Setting the root directory to the folder for this analysis, setting the paths to the countdata, metadata, and probe manifest.
root_dir <- "C:/Users/mmpse/Documents/GitHub/BOO-Adam/QC/02_Probe_QC/"
count_path <- "Input/countData.Rdata"
metadata_path <- "Input/metaData.Rdata"
manifest_path <- "Input/Probe_Manifest.xlsx"
# Setting the paths to the place where future objects will be saved
count_store <- "Output/countData.Rdata"
cpm_store <- "Output/cpmData.Rdata"
metadata_store <- "Output/metaData.Rdata"
probedata_store <- "Output/probeManifest.Rdata"
# count data, metadata and probe manifest are loaded.
load(paste0(root_dir, count_path))
load(paste0(root_dir, metadata_path))
manifest <- read_xlsx(paste0(root_dir, manifest_path))
# original count data is stored for potential use later on
countData_original <- countData
# probe_name_old: probe name from before update
# probe_ID: probe identificator
# probe_sequence: DNA sequence of the probe
# probe_coord: location on the genome where the probe is matched to
# gene_symbol: gene the probe belongs to
# entrez_id, ensembl_id, hgnc_id: several identificators for the gene
# gene_symbol_old, entrez_id_old: gene symbol and entrez id from before update
# percentage_match: percentage with which the probe matches to the gene sequence
str(manifest)
#
setequal(rownames(countData), manifest$probe_name_old)
#
NA_gene_symbol<- sum(is.na(manifest$gene_symbol))
NA_gene_symbol
# Counting the amount of genes that still have the same symbol as before the update
manifest %>%
count(gene_symbol == gene_symbol_old)
# Adding an empty column called flag_realignment
manifest %>%
add_column(flag_realignment = NA)
# flag_realignment column now describes whether a probe should be removed, renamed or kept unchanged.
manifest <- manifest %>%
mutate(flag_realignment =
# when the new gene symbol is equal to the old one, write "unchanged"
case_when(gene_symbol_old == gene_symbol ~ "unchanged",
# when the new gene symbol is not equal to the old one, write "renamed"
gene_symbol_old != gene_symbol ~ "renamed",
# when the new gene symbol is NA, write "removed"
is.na(gene_symbol) ~ "removed"))
# checking if the flag realignment went well. If the realignment went well, this should say: removed: 603, renamed: 608, unchanged: 21322, NA: 0
table(manifest$flag_realignment, useNA = "always")
# subsetted countData to only show the probes which do not have the tag "removed" in the flag_realignment column of manifest_new
countData <- subset(countData, row.names(countData) %in% manifest$probe_name_old & manifest$flag_realignment != "removed")
# The mutate verb adds a probe_name column. The new probe names are gene_symbol and probe_ID, separated by an underscore.
manifest <- manifest %>%
mutate(probe_name = paste(gene_symbol, probe_ID, sep = "_"))
countData <- countData %>%
# turning the row names (probes) back into a column
rownames_to_column(var = "probe_name_old") %>%
# merging the countData with manifest
left_join(y = manifest, by= "probe_name_old") %>%
# selecting only the probe_name and sample_ID columns, these are the two columns of the manifest that will be used in the countData
select(probe_name, all_of(metaData$sample_ID)) %>%
# changing the column probe_name to rownames of the countData: probe_name_old has now been swapped for the new probe_name.
column_to_rownames(var="probe_name")
# Create a data frame of the total CPM (is the sums of each row in cpmData, rounded to 3 decimals) for each probe
manifest <- data.frame(total_cpm = round(rowSums(cpmData), 3)) %>%
# Put the rownames from total_cpm into a column named probe_name
rownames_to_column(var="probe_name") %>%
# Calculate the average CPM across samples for each probe (= total cpm divided by the number of columns (ncol) of cpmData (each column in cpmData is a sample)). This is, again, rounded to 3 decimals.
mutate(avg_cpm = round(total_cpm / ncol(cpmData), 3)) %>%
# Merge with the current probe manifest
right_join(manifest, by="probe_name")
# calculating the counts per million and putting them in a dataframe
cpmData <- data.frame(
# the apply function is used to apply the calculation to the columns ("2") of the countData
apply(countData, 2,
# cpm = (counts / sum of all counts in the column) * 1 million
function(x){x/sum(x)*1000000}))
# Create a data frame of the total CPM (is the sums of each row in cpmData, rounded to 3 decimals) for each probe
manifest <- data.frame(total_cpm = round(rowSums(cpmData), 3)) %>%
# Put the rownames from total_cpm into a column named probe_name
rownames_to_column(var="probe_name") %>%
# Calculate the average CPM across samples for each probe (= total cpm divided by the number of columns (ncol) of cpmData (each column in cpmData is a sample)). This is, again, rounded to 3 decimals.
mutate(avg_cpm = round(total_cpm / ncol(cpmData), 3)) %>%
# Merge with the current probe manifest
right_join(manifest, by="probe_name")
# showing the probes in descending order of expression level, so the highest expressed probe is at the top.
highest_expressed_probes <- manifest_removedprobes %>%
arrange(desc(average_cpm))
# showing the probes in descending order of expression level, so the highest expressed probe is at the top.
highest_expressed_probes <- manifest %>%
arrange(desc(average_cpm))
# showing the probes in descending order of expression level, so the highest expressed probe is at the top.
highest_expressed_probes <- manifest %>%
arrange(desc(avg_cpm))
View(manifest)
highest_expressed_probes
#
manifest %>%
# subsetting the manifest so the unassigned probes are not included
filter(flag_realignment != "removed") %>%
# mutating avg_cpm to log2(avg_cpm+1), so it can be plotted
mutate(log2avg_cpm = log2(avg_cpm+1)) %>%
ggplot() +
# plotting log2avg_cpm as a histogram, with light blue filled bars and a binwidth of 0.2
geom_histogram(aes(x=log2avg_cpm), fill='lightblue', color='black', binwidth = 0.2) +
# creating a red, dashed vertical line at x = 1; this is the threshold for lowly expressed genes.
geom_vline(aes(xintercept=1), color='red', linetype='dashed') +
# labelling the x-axis so that it is clear what the plot means
xlab('log2 of the average CPM (+1) per sample for each probe') +
#
theme(bw)
#
manifest %>%
# subsetting the manifest so the unassigned probes are not included
filter(flag_realignment != "removed") %>%
# mutating avg_cpm to log2(avg_cpm+1), so it can be plotted
mutate(log2avg_cpm = log2(avg_cpm+1)) %>%
ggplot() +
# plotting log2avg_cpm as a histogram, with light blue filled bars and a binwidth of 0.2
geom_histogram(aes(x=log2avg_cpm), fill='lightblue', color='black', binwidth = 0.2) +
# creating a red, dashed vertical line at x = 1; this is the threshold for lowly expressed genes.
geom_vline(aes(xintercept=1), color='red', linetype='dashed') +
# labelling the x-axis so that it is clear what the plot means
xlab('log2 of the average CPM (+1) per sample for each probe') +
#
theme_bw()
#
manifest %>%
# subsetting the manifest so the unassigned probes are not included
filter(flag_realignment != "removed") %>%
# mutating avg_cpm to log2(avg_cpm+1), so it can be plotted
mutate(log2avg_cpm = log2(avg_cpm+1)) %>%
ggplot() +
# plotting log2avg_cpm as a histogram, with light blue filled bars and a binwidth of 0.2
geom_histogram(aes(x=log2avg_cpm), fill='lightblue', color='black', binwidth = 0.2) +
# creating a red, dashed vertical line at x = 1; this is the threshold for lowly expressed genes.
geom_vline(aes(xintercept=1), color='red', linetype='dashed') +
# labelling the x-axis so that it is clear what the plot means
xlab('log2 of the average CPM (+1) per sample for each probe') #+
#
manifest %>%
# subsetting the manifest so the unassigned probes are not included
filter(flag_realignment != "removed") %>%
# mutating avg_cpm to log2(avg_cpm+1), so it can be plotted
mutate(log2avg_cpm = log2(avg_cpm+1)) %>%
ggplot() +
# plotting log2avg_cpm as a histogram, with light blue filled bars and a binwidth of 0.2
geom_histogram(aes(x=log2avg_cpm), fill='lightblue', color='black', binwidth = 0.2) +
# creating a red, dashed vertical line at x = 1; this is the threshold for lowly expressed genes.
geom_vline(aes(xintercept=1), color='red', linetype='dashed') +
# labelling the x-axis so that it is clear what the plot means
xlab('log2 of the average CPM (+1) per sample for each probe') +
#
theme_bw()
#
manifest %>%
# subsetting the manifest so the unassigned probes are not included
filter(flag_realignment != "removed") %>%
# mutating avg_cpm to log2(avg_cpm+1), so it can be plotted
mutate(log2avg_cpm = log2(avg_cpm+1)) %>%
ggplot() +
# plotting log2avg_cpm as a histogram, with light blue filled bars and a binwidth of 0.2
geom_histogram(aes(x=log2avg_cpm), fill='blue', color='black', binwidth = 0.2) +
# creating a red, dashed vertical line at x = 1; this is the threshold for lowly expressed genes.
geom_vline(aes(xintercept=1), color='red', linetype='dashed') +
# labelling the x-axis so that it is clear what the plot means
xlab('log2 of the average CPM (+1) per sample for each probe') +
#
theme_bw()
#
manifest %>%
# subsetting the manifest so the unassigned probes are not included
filter(flag_realignment != "removed") %>%
# mutating avg_cpm to log2(avg_cpm+1), so it can be plotted
mutate(log2avg_cpm = log2(avg_cpm+1)) %>%
ggplot() +
# plotting log2avg_cpm as a histogram, with light blue filled bars and a binwidth of 0.2
geom_histogram(aes(x=log2avg_cpm), fill='pink', color='black', binwidth = 0.2) +
# creating a red, dashed vertical line at x = 1; this is the threshold for lowly expressed genes.
geom_vline(aes(xintercept=1), color='red', linetype='dashed') +
# labelling the x-axis so that it is clear what the plot means
xlab('log2 of the average CPM (+1) per sample for each probe') +
#
theme_bw()
#
manifest %>%
# subsetting the manifest so the unassigned probes are not included
filter(flag_realignment != "removed") %>%
# mutating avg_cpm to log2(avg_cpm+1), so it can be plotted
mutate(log2avg_cpm = log2(avg_cpm+1)) %>%
ggplot() +
# plotting log2avg_cpm as a histogram, with light blue filled bars and a binwidth of 0.2
geom_histogram(aes(x=log2avg_cpm), fill='lightblue', color='black', binwidth = 0.2) +
# creating a red, dashed vertical line at x = 1; this is the threshold for lowly expressed genes.
geom_vline(aes(xintercept=1), color='red', linetype='dashed') +
# labelling the x-axis so that it is clear what the plot means
xlab('log2 of the average CPM (+1) per sample for each probe') +
#
theme_bw()
#
manifest %>%
# subsetting the manifest so the unassigned probes are not included
filter(flag_realignment != "removed") %>%
# mutating avg_cpm to log2(avg_cpm+1), so it can be plotted
mutate(log2avg_cpm = log2(avg_cpm+1)) %>%
ggplot() +
# plotting log2avg_cpm as a histogram, with light blue filled bars and a binwidth of 0.2
geom_histogram(aes(x=log2avg_cpm), fill='lightblue', color='black', binwidth = 0.2) +
# creating a red, dashed vertical line at x = 1; this is the threshold for lowly expressed genes.
geom_vline(aes(xintercept=1), color='red', linetype='dashed') +
# labelling the x-axis so that it is clear what the plot means
xlab('log2 of the average CPM (+1) per sample for each probe') #+
#
manifest %>%
# subsetting the manifest so the unassigned probes are not included
filter(flag_realignment != "removed") %>%
# mutating avg_cpm to log2(avg_cpm+1), so it can be plotted
mutate(log2avg_cpm = log2(avg_cpm+1)) %>%
ggplot() +
# plotting log2avg_cpm as a histogram, with light blue filled bars and a binwidth of 0.2
geom_histogram(aes(x=log2avg_cpm), fill='lightblue', color='black', binwidth = 0.2) +
# creating a red, dashed vertical line at x = 1; this is the threshold for lowly expressed genes.
geom_vline(aes(xintercept=1), color='red', linetype='dashed') +
# labelling the x-axis so that it is clear what the plot means
xlab('log2 of the average CPM (+1) per sample for each probe') +
#
theme_bw()
#
manifest %>%
filter(total_cpm == 0)
#
metaData %>%
group_by(mean_ID) %>%
# Count the number of rows for each mean ID in the metadata
summarize(n_reps = n(), .groups = "drop") %>%
# Keep only unique rows
#distinct()
```
#
metaData %>%
group_by(mean_ID) %>%
# Count the number of rows for each mean ID in the metadata
summarize(n_reps = n(), .groups = "drop")
#
metaData %>%
group_by(mean_ID) %>%
# Count the number of rows for each mean ID in the metadata
summarize(n_reps = n(), .groups = "drop") %>%
# Keep only unique rows
distinct()
#
metaData %>%
group_by(mean_ID) %>%
# Count the number of rows for each mean ID in the metadata
summarize(n_reps = n(), .groups = "drop") #%>%
#
metaData %>%
group_by(mean_ID) %>%
# Count the number of rows for each mean ID in the metadata
summarize(n_reps = n(), .groups = "drop") %>%
# Keep only unique rows
distinct()
#
metaData %>%
group_by(mean_ID) %>%
# Count the number of rows for each mean ID in the metadata
summarize(n_reps = n()) %>%
# Keep only unique rows
distinct()
#
metaData %>%
group_by(mean_ID) %>%
# Count the number of rows for each mean ID in the metadata
summarize(n_reps = n(), .groups = "drop") %>%
# Keep only unique rows
distinct()
metaData %>%
group_by(mean_ID)
#
metaData %>%
group_by(mean_ID) %>%
#
summarize(n_reps = n())
# Creating a vector named loop, containing the experimental conditions
loop <- unique(metaData$mean_ID)
loop
# Creating the dataframe relevanceFilter
relevanceFilter <- data.frame(probe_name = rownames(cpmData))
View(relevanceFilter)
View(metaData)
# Creating the dataframe relevanceFilter, which contains only the rownames of cpmdata
relevanceFilter <- data.frame(probe_name = rownames(cpmData))
# For each unique mean ID (= each unique condition)
for(i in loop){
# Subset metadata to include only samples with that mean ID (so, for each loop, the samples of one unique condition are selected)
set <- metaData %>%
filter(mean_ID == i)
# Subset the CPM data to include only those samples (so you have the cpm data for all repetitions of the condition)
cpm.set <- cpmData[ , set$sample_ID]
# Count the percentage of values for each probe that are above 1 (CPM above 1 is the threshold for relevance)
df.set <- data.frame(round(100 * rowSums(cpm.set > 1) / ncol(cpm.set), 2)) %>%
rownames_to_column(var = "probe_name")
# Set the column name to the current mean ID
colnames(df.set) <- c("probe_name", i)
# Merge with the relevance filter output thus far (so that all values will appear in the same dataframe)
relevanceFilter <- left_join(relevanceFilter, df.set, by="probe_name")
}
# Turn the probe name column back into row names
relevanceFilter <- relevanceFilter %>%
column_to_rownames(var="probe_name")
# Show the first 6 rows of the output
head(relevanceFilter)
View(relevanceFilter)
relevanceFilter <- relevanceFilter %>%
# Create a variable counting the number of rows with a value above 66 -> a probe is relevant if it has a value of >1 in at least two thirds of the data (so at least 66% of the replications)
mutate(n_relevant = rowSums(relevanceFilter >= 66)) %>%
# Move this column to the first place in the data frame
select(n_relevant, everything()) %>%
# Convert row names to a new column called probe_name
rownames_to_column(var="probe_name")
# Merge with the manifest using this new column
manifest <- left_join(manifest, relevanceFilter, by="probe_name")
# Summarize the number of relevant experiments for each probe
summary(manifest$n_relevant)
# A probe is relevant if it passes the threshold (cpm >1 in at least 2/3 of the repetitions) for at least 1 experimental condition
probeManifest <- probeManifest %>%
mutate(flag_relevant = ifelse(n_relevant >= 1, T, F))
# A probe is relevant if it passes the threshold (cpm >1 in at least 2/3 of the repetitions) for at least 1 experimental condition
manifest <- manifest %>%
mutate(flag_relevant = ifelse(n_relevant >= 1, T, F))
# Tabulate the relevance flag
table(manifest$flag_relevant, useNA="always")
# Put the probes that pass the filter into a vector
kept <- (manifest %>%
filter(flag_relevant == T))$probe_name
# Check the dimensions of the count data to make sure they are still correct
dim(countData)
# Subset the count data so that it contains only the relevant probes
countData <- countData[kept, ]
# Check dimensions again following the subset
dim(countData)
# manifest is filtered so only assigned probes are used in the plot
manifest %>%
filter(flag_realignment != "Probe removed") %>%
ggplot() +
# A histogram is made with the number of relevant probes on the x-axis.
geom_histogram(aes(x = n_relevant,
# Bins for relevant and irrelevant probes will be filled with a different color
fill = flag_relevant),
color = "grey20",
binwidth = 1) +
# setting axis labels and a figure title
xlab(paste0("Number of conditions where a probe reaches 1 CPM in at least 66% reps")) +
ylab("Number of probes") +
ggtitle("Relevance distribution") +
# theme makes the plot look cleaner
theme_bw()
# Remove the legend
#theme(legend.position = "none")
# manifest is filtered so only assigned probes are used in the plot
manifest %>%
filter(flag_realignment != "Probe removed") %>%
ggplot() +
# A histogram is made with the number of relevant probes on the x-axis.
geom_histogram(aes(x = n_relevant,
# Bins for relevant and irrelevant probes will be filled with a different color
fill = flag_relevant),
color = "grey20",
binwidth = 1) +
# setting axis labels and a figure title
xlab(paste0("Number of conditions where a probe reaches 1 CPM in at least 66% reps")) +
ylab("Number of probes") +
ggtitle("Relevance distribution") +
# theme makes the plot look cleaner
theme_bw() +
# Remove the legend
theme(legend.position = "none")
# filterin the manifest so it shows only the probes that are relevant in all of the conditions. NA values are removed.
probeManifest %>%
filter(n_relevant == max(n_relevant, na.rm=T))
# filterin the manifest so it shows only the probes that are relevant in all of the conditions. NA values are removed.
manifest %>%
filter(n_relevant == max(n_relevant, na.rm=T))
manifest %>%
# unaligned probes are filtered out
filter(flag_realignment != "Probe removed") %>%
# add a column with the log2(cpm + 1) of the average cpm
mutate(log2avg_cpm = log2(avg_cpm + 1)) %>%
ggplot() +
# create a histogram with the log2avg_cpm on the x-axis
geom_histogram(aes(x = log2avg_cpm,
# bins are color-filled by relevance
fill = flag_relevant),
color = "black", binwidth = 0.2) +
# label is added on the x-axis, plot title is added
xlab("log2 of the average CPM (+1) per sample for each probe") +
ggtitle("Distribution of log2 (CPM + 1) values colored by relevance") +
# the theme makes the plot look cleaner
theme_bw() +
# remove the legend from the plot
theme(legend.position='none')
countData <- countData %>%
# change the row names of countData into a column called probe_name
rownames_to_column(var = "probe_name") %>%
# reduce the probe name to just the gene symbol, by removing the probe ID (making it NA) and separator.
separate(probe_name,
into=c("gene_symbol", NA),
sep = "_") %>%
# group the data by gene symbol
group_by(gene_symbol) %>%
# add the values in each row to each other, so that the counts of each gene are taken together.
summarise(across(where(is.numeric), sum),
# remove the grouping to avoid future errors
.groups = "drop") %>%
# turn the column gene_symbol into row names
column_to_rownames(var = "gene_symbol")
# show the first 10 rows of countData
countData[1:10, ]
cpmData <- data.frame(
# for each row, calculate cpm (cpm = (counts / sum of all counts in the column) * 1 million)
apply(countData, 2, function(x){x/sum(x)*1E6}))
cpmData[1:10, ]
#
save(manifest, file=paste0(root_dir, probedata_store))
save(countData, file=paste0(root_dir, count_store))
save(cpmData, file=paste0(root_dir, cpm_store))
#
devtools::session_info()
#
install.packages(devtools)
#
install.packages("devtools")
#
devtools::session_info()
rm(list=ls())
root_dir <- "C:/Users/mmpse/Documents/GitHub/BOO-Adam/QC/03_Sample_QC/"
count_path <- "Input/countData.Rdata"
cpm_path <- "Input/cpmData.Rdata"
metadata_path <- "Input/metaData.Rdata"
count_store <- "Output/countData.Rdata"
cpm_store <- "Output/cpmData.Rdata"
metadata_store <- "Output/metaData.Rdata"
# Set count threshold to 600,000
count_threshold <- 600000
# Set correlation threshold to 0.9
corr_threshold <- 0.9
root_dir <- "C:/Users/mmpse/Documents/GitHub/BOO-Adam/QC/03_Sample_QC/"
count_path <- "Input/countData.Rdata"
cpm_path <- "Input/cpmData.Rdata"
metadata_path <- "Input/metaData.Rdata"
count_store <- "Output/countData.Rdata"
cpm_store <- "Output/cpmData.Rdata"
metadata_store <- "Output/metaData.Rdata"
# Set count threshold to 600,000; this is the minimum library size the samples need to have
count_threshold <- 600000
# Set correlation threshold to 0.9; this is the level of correlation replicates of the same condition need to have
corr_threshold <- 0.9
library(tidyverse)
library(ggrepel)
